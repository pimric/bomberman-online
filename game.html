<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Island Bomber</title>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
    <style>
        /* Styles pour le jeu Island Bomber */
        body {
            background: linear-gradient(135deg, #0099cc, #006699);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            color: white;
            background-image: url('https://cdnjs.cloudflare.com/ajax/libs/line-awesome/1.3.0/svg/palm-tree.svg');
            background-repeat: repeat;
            background-size: 100px;
            background-blend-mode: soft-light;
        }

        #gameContainer {
            text-align: center;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border: 3px solid #ffd700;
        }

        canvas {
            border: 4px solid #ffd700;
            background-color: #f9e8b0; /* Sand color */
            image-rendering: pixelated;
            border-radius: 8px;
        }

        h1 {
            font-family: 'Pacifico', cursive;
            font-size: 36px;
            color: #ffd700; /* Gold color for reggae vibe */
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 2px 2px 0px #000, 4px 4px 0px #006699;
            font-weight: bold;
        }

        #roomControls {
            margin: 20px 0;
            padding: 15px;
            background-color: rgba(34, 139, 34, 0.7); /* Forest green with opacity */
            border-radius: 10px;
            border: 2px dashed #ffd700;
        }

        button {
            background: linear-gradient(to bottom, #ff9900, #ff6600);
            color: white;
            border: none;
            padding: 10px 18px;
            margin: 0 8px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            font-weight: bold;
            font-size: 14px;
            text-transform: uppercase;
            box-shadow: 0 4px 0 #cc5200;
            transition: all 0.2s;
        }

        button:hover {
            background: linear-gradient(to bottom, #ffaa33, #ff7722);
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #cc5200;
        }

        button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #cc5200;
        }

        input {
            background-color: #ffe6cc;
            color: #663300;
            border: 2px solid #ff9900;
            padding: 10px;
            border-radius: 8px;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            font-size: 14px;
            width: 150px;
        }

        input::placeholder {
            color: #cc8800;
        }

        /* Styles pour les explosions */
        .explosion-animation {
            position: absolute;
            background-color: rgba(255, 165, 0, 0.7);
            border-radius: 50%;
            animation: explode 0.5s ease-out;
        }

        @keyframes explode {
            0% { transform: scale(0.5); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        .gameButton {
            background: linear-gradient(to bottom, #ff9900, #ff6600);
            color: white;
            padding: 12px 20px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            margin: 8px;
            cursor: pointer;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            box-shadow: 0 4px 0 #cc5200;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .gameButton:hover {
            background: linear-gradient(to bottom, #ffaa33, #ff7722);
            transform: translateY(-2px);
            box-shadow: 0 6px 0 #cc5200;
        }

        .gameButton:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #cc5200;
        }

        #gameInfo {
            background-color: rgba(255, 215, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-weight: bold;
            text-shadow: 1px 1px 0px #000;
            letter-spacing: 1px;
        }

        /* Styles pour les bonus */
        .bonus {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            animation: pulse 1s infinite alternate;
        }

        @keyframes pulse {
            0% { transform: scale(0.9); }
            100% { transform: scale(1.1); }
        }

        /* Styles pour le panneau de debug (optionnel) */
        #debug {
            display: none;
            margin-top: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            text-align: left;
            font-size: 12px;
            max-height: 150px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1>Island Bomber</h1>
        
        <div id="roomControls">
            <input type="text" id="roomInput" placeholder="Code de partie">
            <button id="createBtn">Créer partie</button>
            <button id="joinBtn">Rejoindre partie</button>
            <button id="singlePlayerBtn">Affronter le Pirate IA</button>
        </div>
        
        <div id="gameInfo">Bienvenue sur l'île ! Prêt à exploser des noix de coco ?</div>
        <canvas id="gameCanvas" width="480" height="480"></canvas>
    </div>

    <div id="gameControls" style="display: none; margin-top: 10px;">
        <button id="restartBtn" class="gameButton">Nouvelle Partie</button>
        <button id="homeBtn" class="gameButton">Retour à l'île</button>
    </div>

    <!-- Optionnel: Panneau de debug -->
    <div id="debug" style="display: none;">
        <div>IA - Position: <span id="aiGridX">0</span>, <span id="aiGridY">0</span> | Bombes: <span id="aiBombs">1</span> | Puissance: <span id="aiPower">2</span></div>
        <div>Joueur - Position: <span id="playerGridX">0</span>, <span id="playerGridY">0</span> | Bombes: <span id="playerBombs">1</span> | Puissance: <span id="playerPower">2</span></div>
        <div>Action IA: <span id="aiAction">-</span></div>
    </div>

    <!-- Import Firebase SDK -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.9.0/firebase-app-compat.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/9.9.0/firebase-database-compat.js"></script>

    <script>
        // Ajout d'un système de journalisation simple
        function log(message) {
            console.log(`[${new Date().toISOString()}] ${message}`);
        }

        log("Script démarré");

        //--------------------------------------------------
        // CONFIGURATION DU JEU
        //--------------------------------------------------
        const GRID_SIZE = 15;
        const TILE_SIZE = 32;
        const PLAYER_SPEED = 3;
        const COLLISION_MARGIN = 6;

        // Définir les types de cases
        const TILE_TYPES = {
            EMPTY: 0,  // Sable
            WALL: 1,   // Palmiers
            BRICK: 2   // Tonneaux
        };

        // Configuration des bombes
        const BOMB_TIMER = 3000; // Délai avant explosion (ms)
        const EXPLOSION_DURATION = 1000; // Durée d'affichage de l'explosion (ms)

        // Configuration de l'IA
        const AI_MOVE_DELAY = 300; // Délai entre les mouvements de l'IA (ms)
        const AI_BOMB_PROBABILITY = 0.2; // Probabilité de poser une bombe

        // Configuration des bonus
        const BONUS_PROBABILITY = 0.5; // 50% de chance qu'un tonneau détruit laisse un bonus
        const BONUS_DURATION = 15000; // Les bonus restent 15 secondes sur la carte

        // Types de bonus
        const BONUS_TYPES = {
            BOMB: 0,    // Bombe supplémentaire
            POWER: 1,   // Augmente la portée des bombes
            SPEED: 2    // Augmente la vitesse de déplacement
        };

        // Configuration Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyDEDfD0gETLAra2wu9e0V8YVECdshVWAEc",
            authDomain: "bomberman-10e44.firebaseapp.com",
            projectId: "bomberman-10e44",
            storageBucket: "bomberman-10e44.firebasestorage.app",
            messagingSenderId: "734188613745",
            appId: "1:734188613745:web:96b85d282821b3613d2bd0"
        };

        // Initialiser Firebase
        log("Initialisation de Firebase");
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        // État du jeu global
        const gameState = {
            roomId: null,
            playerId: null,
            map: [],
            players: {},
            bombs: [],
            explosions: [],
            bonuses: [],
            gameStarted: false,
            keys: {},
            lastKeys: {}, // Pour détecter les nouvelles pressions
            aiActive: true
        };

        // Variables de l'IA
        let aiMode = false;
        let aiPlayerId = 'playerAI';
        let aiMoveInterval;
        let aiLastMove = { dx: 0, dy: 0 };
        let aiLastTargetUpdate = 0;

        // Références DOM
        log("Récupération des références DOM");
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameInfo = document.getElementById('gameInfo');
        const roomInput = document.getElementById('roomInput');
        const debugDiv = document.getElementById('debug');

        //--------------------------------------------------
        // FONCTIONS DE BASE DU JEU
        //--------------------------------------------------

        // Générer une carte aléatoire avec des chemins garantis
        function generateMap() {
            const map = [];
            
            // Initialiser la carte avec des murs fixes et le reste vide
            for (let y = 0; y < GRID_SIZE; y++) {
                const row = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (x % 2 === 0 && y % 2 === 0) {
                        // Murs fixes qui ne peuvent pas être détruits (palmiers)
                        row.push(TILE_TYPES.WALL);
                    } else {
                        // Tout le reste est vide au départ (sable)
                        row.push(TILE_TYPES.EMPTY);
                    }
                }
                map.push(row);
            }
            
            // Garantir des zones de départ vides pour les joueurs
            // Pour le joueur 1 (coin supérieur gauche)
            map[0][0] = TILE_TYPES.EMPTY;
            map[0][1] = TILE_TYPES.EMPTY;
            map[1][0] = TILE_TYPES.EMPTY;
            
            // Pour l'IA ou le joueur 2 (coin inférieur droit)
            map[GRID_SIZE-1][GRID_SIZE-1] = TILE_TYPES.EMPTY;
            map[GRID_SIZE-1][GRID_SIZE-2] = TILE_TYPES.EMPTY;
            map[GRID_SIZE-2][GRID_SIZE-1] = TILE_TYPES.EMPTY;
            
            // Ajouter des briques destructibles de manière aléatoire (tonneaux)
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    // Si c'est un emplacement vide (pas un palmier) et pas dans les zones de départ
                    if (map[y][x] === TILE_TYPES.EMPTY && 
                        !((x <= 1 && y <= 1) || (x >= GRID_SIZE-2 && y >= GRID_SIZE-2))) {
                        
                        // Probabilité de 60% d'avoir un tonneau
                        if (Math.random() < 0.6) {
                            map[y][x] = TILE_TYPES.BRICK;
                        }
                    }
                }
            }
            
            // Garantir un chemin entre le coin supérieur gauche et le coin inférieur droit
            
            // Chemin horizontal
            for (let x = 2; x < GRID_SIZE - 2; x += 2) {
                map[1][x] = TILE_TYPES.EMPTY;
            }
            
            // Chemin vertical
            for (let y = 3; y < GRID_SIZE - 1; y += 2) {
                map[y][GRID_SIZE - 2] = TILE_TYPES.EMPTY;
            }
            
            return map;
        }

        // Créer un joueur
        function createPlayer(x, y, color) {
            return {
                x: x * TILE_SIZE + TILE_SIZE / 2,
                y: y * TILE_SIZE + TILE_SIZE / 2,
                radius: TILE_SIZE / 2 - 4,
                color: color,
                maxBombs: 1,
                bombRange: 2,
                speedMultiplier: 1,
                alive: true
            };
        }

        // Générer un ID unique
        function generateId() {
            return Math.random().toString(36).substr(2, 9);
        }

        // Vérification de position améliorée
        function isValidPosition(x, y) {
            const gridX = Math.floor(x / TILE_SIZE);
            const gridY = Math.floor(y / TILE_SIZE);
            
            // Vérifier si on est dans les limites de la carte
            if (gridX < 0 || gridX >= GRID_SIZE || gridY < 0 || gridY >= GRID_SIZE) {
                return false;
            }
            
            // Vérifier en tenant compte d'une "hitbox" légèrement plus petite que le joueur
            const margin = COLLISION_MARGIN; // Marge en pixels
            
            // Vérifier les quatre coins du joueur avec la marge
            const points = [
                { x: x - TILE_SIZE/2 + margin, y: y - TILE_SIZE/2 + margin }, // Coin supérieur gauche
                { x: x + TILE_SIZE/2 - margin, y: y - TILE_SIZE/2 + margin }, // Coin supérieur droit
                { x: x - TILE_SIZE/2 + margin, y: y + TILE_SIZE/2 - margin }, // Coin inférieur gauche
                { x: x + TILE_SIZE/2 - margin, y: y + TILE_SIZE/2 - margin }  // Coin inférieur droit
            ];
            
            // Vérifier chaque point
            for (const point of points) {
                const pointGridX = Math.floor(point.x / TILE_SIZE);
                const pointGridY = Math.floor(point.y / TILE_SIZE);
                
                // Si ce point est hors des limites ou sur un obstacle
                if (pointGridX < 0 || pointGridX >= GRID_SIZE || 
                    pointGridY < 0 || pointGridY >= GRID_SIZE ||
                    gameState.map[pointGridY][pointGridX] !== TILE_TYPES.EMPTY) {
                    return false;
                }
            }
            
            return true;
        }

        // Vérifier si une grille est accessible
        function isGridAccessible(gridX, gridY) {
            if (gridX < 0 || gridX >= GRID_SIZE || gridY < 0 || gridY >= GRID_SIZE) {
                return false;
            }
            
            return gameState.map[gridY][gridX] === TILE_TYPES.EMPTY;
        }
        
        // Vérifier si une case contient une bombe
        function hasBomb(gridX, gridY) {
            return gameState.bombs.some(bomb => bomb.x === gridX && bomb.y === gridY);
        }

        // Mettre à jour la position du joueur avec une meilleure gestion des collisions
        function updatePlayerPosition(playerData, dx, dy) {
            // Appliquer le multiplicateur de vitesse
            const speedMultiplier = playerData.speedMultiplier || 1;
            dx *= speedMultiplier;
            dy *= speedMultiplier;
            
            // Essayer de bouger sur les deux axes indépendamment
            const newX = playerData.x + dx;
            const newY = playerData.y + dy;
            
            // Essayer d'abord le mouvement complet
            if (isValidPosition(newX, newY)) {
                playerData.x = newX;
                playerData.y = newY;
                return;
            }
            
            // Si le mouvement complet échoue, essayer juste horizontalement
            if (dx !== 0 && isValidPosition(newX, playerData.y)) {
                playerData.x = newX;
            }
            
            // Puis essayer juste verticalement
            if (dy !== 0 && isValidPosition(playerData.x, newY)) {
                playerData.y = newY;
            }
        }

        // Vérifier fin de partie
        function checkGameOver() {
            if (!gameState.gameStarted) return false;
            
            // En mode IA
            if (aiMode) {
                const player = gameState.players['player1'];
                const ai = gameState.players[aiPlayerId];
                
                // Si le joueur est mort
                if (player && !player.alive) {
                    if (aiMoveInterval) clearInterval(aiMoveInterval);
                    gameInfo.textContent = `Game Over - Le pirate a gagné !`;
                    document.getElementById('gameControls').style.display = 'block';
                    return true;
                }
                
                // Si l'IA est morte
                if (ai && !ai.alive) {
                    if (aiMoveInterval) clearInterval(aiMoveInterval);
                    gameInfo.textContent = `Victoire - Vous avez battu le pirate !`;
                    document.getElementById('gameControls').style.display = 'block';
                    return true;
                }
            } 
            // En mode multijoueur
            else {
                const player1 = gameState.players['player1'];
                const player2 = gameState.players['player2'];
                
                // Si les deux joueurs sont présents et que l'un est mort
                if (player1 && player2) {
                    if (!player1.alive) {
                        gameInfo.textContent = gameState.playerId === 'player1' ? 
                            `Game Over - Le Surfeur Bleu a gagné !` : 
                            `Victoire - Vous avez gagné !`;
                        document.getElementById('gameControls').style.display = 'block';
                        return true;
                    }
                    
                    if (!player2.alive) {
                        gameInfo.textContent = gameState.playerId === 'player2' ? 
                            `Game Over - Le Rasta Rouge a gagné !` : 
                            `Victoire - Vous avez gagné !`;
                        document.getElementById('gameControls').style.display = 'block';
                        return true;
                    }
                }
            }
            
            return false;
        }

        // Mettre à jour l'état du jeu
        function update() {
            if (!gameState.roomId || !gameState.playerId || !gameState.gameStarted) return;
            
            // Vérifier si le jeu est terminé
            if (checkGameOver()) return;
            
            const player = gameState.players[gameState.playerId];
            if (!player || !player.alive) return;
            
            let playerMoved = false;
            
            // Mouvement pour tous les joueurs
            if (gameState.keys['ArrowUp']) {
                updatePlayerPosition(player, 0, -PLAYER_SPEED);
                playerMoved = true;
            }
            if (gameState.keys['ArrowDown']) {
                updatePlayerPosition(player, 0, PLAYER_SPEED);
                playerMoved = true;
            }
            if (gameState.keys['ArrowLeft']) {
                updatePlayerPosition(player, -PLAYER_SPEED, 0);
                playerMoved = true;
            }
            if (gameState.keys['ArrowRight']) {
                updatePlayerPosition(player, PLAYER_SPEED, 0);
                playerMoved = true;
            }
            
            // Mettre à jour la position sur Firebase si le joueur a bougé
            if (playerMoved) {
                database.ref(`games/${gameState.roomId}/players/${gameState.playerId}`).update({
                    x: player.x,
                    y: player.y
                });
            }
            
            // Mettre à jour les explosions
            updateExplosions();
            
            // Mettre à jour les bonus (expiration)
            updateBonuses();
            
            // Vérifier les bonus collectés
            checkBonusCollection();
        }

        // Dessiner le jeu
        function render() {
            // Effacer le canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Si pas de jeu en cours, afficher un écran d'attente
            if (!gameState.map || gameState.map.length === 0) {
                ctx.fillStyle = '#006699';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '16px "Comic Sans MS"';
                ctx.textAlign = 'center';
                ctx.fillText('En attente de la création/connexion à une partie...', canvas.width/2, canvas.height/2);
                return;
            }
            
            // Dessiner la carte
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const tileType = gameState.map[y][x];
                    const tileX = x * TILE_SIZE;
                    const tileY = y * TILE_SIZE;
                    
                    // Couleur selon le type de case
                    if (tileType === TILE_TYPES.WALL) {
                        // Mur solide (style palmier)
                        ctx.fillStyle = '#006633';
                    } else if (tileType === TILE_TYPES.BRICK) {
                        // Briques destructibles (tonneaux)
                        ctx.fillStyle = '#993300';
                    } else {
                        // Cases vides (sable)
                        ctx.fillStyle = '#f9e8b0';
                    }
                    
                    // Dessiner la case
                    ctx.fillRect(tileX, tileY, TILE_SIZE, TILE_SIZE);
                    
                    // Ajouter une bordure
                    ctx.strokeStyle = '#111';
                    ctx.strokeRect(tileX, tileY, TILE_SIZE, TILE_SIZE);
                    
                    // Ajouter des détails selon le type
                    if (tileType === TILE_TYPES.WALL) {
                        // Dessiner un petit palmier
                        ctx.fillStyle = '#004d00';
                        ctx.fillRect(tileX + 5, tileY + 15, 8, 12);
                        ctx.beginPath();
                        ctx.moveTo(tileX + 9, tileY + 15);
                        ctx.lineTo(tileX + 3, tileY + 5);
                        ctx.lineTo(tileX + 15, tileY + 8);
                        ctx.lineTo(tileX + 9, tileY + 15);
                        ctx.fill();
                    } else if (tileType === TILE_TYPES.BRICK) {
                        // Dessiner les lignes du tonneau
                        ctx.strokeStyle = '#cc6600';
                        ctx.beginPath();
                        ctx.moveTo(tileX, tileY + 10);
                        ctx.lineTo(tileX + TILE_SIZE, tileY + 10);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(tileX, tileY + 20);
                        ctx.lineTo(tileX + TILE_SIZE, tileY + 20);
                        ctx.stroke();
                    }
                }
            }
            
            // Dessiner les bonus
            renderBonuses();
            
            // Dessiner les explosions
            renderExplosions();
            
            // Dessiner les bombes
            renderBombs();
            
            // Dessiner les joueurs
            for (const playerId in gameState.players) {
                const playerData = gameState.players[playerId];
                if (playerData && playerData.alive) {
                    // Fond du joueur
                    ctx.fillStyle = playerData.color;
                    ctx.beginPath();
                    ctx.arc(playerData.x, playerData.y, playerData.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Visage du personnage
                    ctx.fillStyle = 'white';
                    // Yeux
                    ctx.beginPath();
                    ctx.arc(playerData.x - 5, playerData.y - 3, 3, 0, Math.PI * 2);
                    ctx.arc(playerData.x + 5, playerData.y - 3, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Pupilles
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(playerData.x - 5, playerData.y - 3, 1.5, 0, Math.PI * 2);
                    ctx.arc(playerData.x + 5, playerData.y - 3, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Sourire
                    ctx.beginPath();
                    ctx.arc(playerData.x, playerData.y + 2, 5, 0, Math.PI);
                    ctx.stroke();
                }
            }
        }

        //--------------------------------------------------
        // LOGIQUE DE L'IA AMÉLIORÉE
        //--------------------------------------------------

        // Démarrer l'IA
        function startAI() {
            if (aiMoveInterval) clearInterval(aiMoveInterval);
            
            log("IA activée");
            
            aiMoveInterval = setInterval(() => {
                if (!gameState.gameStarted || !aiMode) return;
                
                const aiPlayer = gameState.players[aiPlayerId];
                if (!aiPlayer || !aiPlayer.alive) {
                    clearInterval(aiMoveInterval);
                    return;
                }
                
                // Logique de mouvement de l'IA améliorée
                moveAI(aiPlayer);
                
                // Possibilité de placer une bombe
                if (Math.random() < AI_BOMB_PROBABILITY) {
                    tryPlaceAIBomb(aiPlayer);
                }
            }, AI_MOVE_DELAY);
        }

        // Déplacer l'IA - version améliorée
        function moveAI(aiPlayer) {
            // Obtenir la position actuelle de l'IA sur la grille
            const gridX = Math.floor(aiPlayer.x / TILE_SIZE);
            const gridY = Math.floor(aiPlayer.y / TILE_SIZE);
            
            // S'assurer que l'IA est bien centrée sur sa case actuelle
            const centerX = gridX * TILE_SIZE + TILE_SIZE / 2;
            const centerY = gridY * TILE_SIZE + TILE_SIZE / 2;
            
            // Si l'IA n'est pas bien centrée, la recentrer d'abord
            if (Math.abs(aiPlayer.x - centerX) > 2 || Math.abs(aiPlayer.y - centerY) > 2) {
                const dx = Math.sign(centerX - aiPlayer.x) * Math.min(PLAYER_SPEED, Math.abs(centerX - aiPlayer.x));
                const dy = Math.sign(centerY - aiPlayer.y) * Math.min(PLAYER_SPEED, Math.abs(centerY - aiPlayer.y));
                
                if (dx !== 0) aiPlayer.x += dx;
                if (dy !== 0) aiPlayer.y += dy;
                
                // Synchroniser avec Firebase
                database.ref(`games/${gameState.roomId}/players/${aiPlayerId}`).update({
                    x: aiPlayer.x,
                    y: aiPlayer.y
                });
                
                updateDebugInfo("Recentrage");
                return; // Ne pas faire d'autre mouvement pour ce tour
            }
            
            // Vérifier s'il y a un bonus à collecter à cette position
            if (getBonusAt(gridX, gridY)) {
                collectBonus(aiPlayerId, getBonusAt(gridX, gridY));
                updateDebugInfo("Bonus collecté!");
                return;
            }
            
            // Directions possibles: haut, bas, gauche, droite
            const directions = [
                { dx: 0, dy: -1, name: 'haut' },
                { dx: 0, dy: 1, name: 'bas' },
                { dx: -1, dy: 0, name: 'gauche' },
                { dx: 1, dy: 0, name: 'droite' }
            ];
            
            // Filtrer les directions valides (sans obstacle)
            const validDirections = directions.filter(dir => {
                // Vérifier la position après le mouvement complet
                const newGridX = Math.floor((aiPlayer.x + dir.dx * 4) / TILE_SIZE);
                const newGridY = Math.floor((aiPlayer.y + dir.dy * 4) / TILE_SIZE);
                
                if (newGridX !== gridX || newGridY !== gridY) {
                    // On vérifie si la nouvelle case est accessible
                    return newGridX >= 0 && newGridX < GRID_SIZE && 
                           newGridY >= 0 && newGridY < GRID_SIZE && 
                           gameState.map[newGridY][newGridX] === TILE_TYPES.EMPTY &&
                           !hasBomb(newGridX, newGridY);
                }
                
                // Si on reste sur la même case, c'est valide
                return true;
            });
            
            // Si aucune direction valide, rester immobile
            if (validDirections.length === 0) {
                // Si l'IA est bloquée, essayer de poser une bombe pour se frayer un chemin
                if (Math.random() < 0.5) {
                    tryPlaceAIBomb(aiPlayer);
                }
                updateDebugInfo("Bloqué");
                return;
            }
            
            // Vérifier s'il y a des bombes à proximité
            const nearbyBomb = isNearExplosion(gridX, gridY);
            
            let chosenDirection;
            
            // Si une bombe est à proximité, fuir
            if (nearbyBomb) {
                chosenDirection = getBestEscapeDirection(gridX, gridY, validDirections);
                updateDebugInfo("Fuite de bombe");
            } else {
                // Vérifier s'il y a un bonus à proximité
                const nearestBonus = findNearestBonus(gridX, gridY);
                
                if (nearestBonus && nearestBonus.distance < 5) {
                    // Aller vers le bonus
                    validDirections.sort((a, b) => {
                        const distA = Math.abs((gridX + a.dx) - nearestBonus.bonus.x) + 
                                      Math.abs((gridY + a.dy) - nearestBonus.bonus.y);
                        const distB = Math.abs((gridX + b.dx) - nearestBonus.bonus.x) + 
                                      Math.abs((gridY + b.dy) - nearestBonus.bonus.y);
                        return distA - distB;
                    });
                    
                    chosenDirection = validDirections[0];
                    updateDebugInfo("Vers bonus");
                } else {
                    // Comportement normal: se diriger vers le joueur humain
                    const player = gameState.players['player1'];
                    
                    if (player && player.alive) {
                        // Éviter les mouvements d'aller-retour
                        const nonBacktrackingMoves = validDirections.filter(dir =>
                            !(dir.dx === -aiLastMove.dx && dir.dy === -aiLastMove.dy)
                        );
                        
                        const movesToConsider = nonBacktrackingMoves.length > 0 ? 
                                               nonBacktrackingMoves : validDirections;
                        
                        // Intelligence simple: chercher à s'approcher du joueur humain
                        const distanceToPlayer = Math.sqrt(
                            Math.pow((player.x - aiPlayer.x) / TILE_SIZE, 2) + 
                            Math.pow((player.y - aiPlayer.y) / TILE_SIZE, 2)
                        );
                        
                        if (distanceToPlayer < 3 && Math.random() < 0.3) {
                            // Échapper au joueur s'il est trop proche (parfois)
                            const playerDirX = player.x > aiPlayer.x ? 1 : -1;
                            const playerDirY = player.y > aiPlayer.y ? 1 : -1;
                            
                            // Chercher une direction qui s'éloigne du joueur
                            const escapeDirs = movesToConsider.filter(dir => {
                                return (dir.dx * playerDirX <= 0) || (dir.dy * playerDirY <= 0);
                            });
                            
                            chosenDirection = escapeDirs.length > 0 
                                ? escapeDirs[Math.floor(Math.random() * escapeDirs.length)]
                                : movesToConsider[Math.floor(Math.random() * movesToConsider.length)];
                                
                            updateDebugInfo("Évite joueur");
                            
                            // Forte chance de poser une bombe près du joueur
                            if (distanceToPlayer < 2 && Math.random() < 0.6) {
                                tryPlaceAIBomb(aiPlayer);
                            }
                        } else {
                            // Se déplacer vers le joueur
                            movesToConsider.sort((a, b) => {
                                const distA = Math.abs((gridX + a.dx) - Math.floor(player.x / TILE_SIZE)) + 
                                             Math.abs((gridY + a.dy) - Math.floor(player.y / TILE_SIZE));
                                const distB = Math.abs((gridX + b.dx) - Math.floor(player.x / TILE_SIZE)) + 
                                             Math.abs((gridY + b.dy) - Math.floor(player.y / TILE_SIZE));
                                return distA - distB;
                            });
                            
                            // Ajouter du hasard pour que l'IA ne soit pas trop prévisible
                            chosenDirection = Math.random() < 0.7 
                                ? movesToConsider[0] // 70% de chance de prendre la meilleure direction
                                : movesToConsider[Math.floor(Math.random() * movesToConsider.length)];
                                
                            updateDebugInfo("Vers joueur");
                        }
                    } else {
                        // Si pas de joueur, déplacement aléatoire
                        chosenDirection = validDirections[Math.floor(Math.random() * validDirections.length)];
                        updateDebugInfo("Aléatoire");
                    }
                }
            }
            
            // Appliquer le mouvement
            const speedMultiplier = aiPlayer.speedMultiplier || 1;
            const newX = aiPlayer.x + chosenDirection.dx * PLAYER_SPEED * speedMultiplier;
            const newY = aiPlayer.y + chosenDirection.dy * PLAYER_SPEED * speedMultiplier;
            
            // Vérifier une dernière fois si la position est valide
            if (isValidPosition(newX, newY)) {
                // Mettre à jour la position de l'IA
                aiPlayer.x = newX;
                aiPlayer.y = newY;
                
                // Mémoriser le dernier mouvement pour éviter les aller-retours
                aiLastMove = { dx: chosenDirection.dx, dy: chosenDirection.dy };
                
                // Synchroniser avec Firebase
                database.ref(`games/${gameState.roomId}/players/${aiPlayerId}`).update({
                    x: aiPlayer.x,
                    y: aiPlayer.y
                });
            }
        }

        // Vérifier si l'IA est près d'une explosion imminente ou en cours
        function isNearExplosion(gridX, gridY) {
            // Vérifier les bombes à proximité qui vont bientôt exploser
            const dangerBombs = gameState.bombs.filter(bomb => {
                // Si la bombe va exploser dans moins de 1 seconde
                const timeToExplode = bomb.timer - Date.now();
                if (timeToExplode <= 1000) {
                    // Calculer la distance
                    const distX = Math.abs(bomb.x - gridX);
                    const distY = Math.abs(bomb.y - gridY);
                    // Si dans la portée potentielle
                    return (distX <= bomb.range && distY === 0) || 
                           (distY <= bomb.range && distX === 0);
                }
                return false;
            });
            
            // Vérifier les explosions actives
            const inExplosion = gameState.explosions.some(explosion => {
                return explosion.cells.some(cell => cell.x === gridX && cell.y === gridY);
            });
            
            return dangerBombs.length > 0 || inExplosion;
        }

        // Obtenir la meilleure direction pour fuir
        function getBestEscapeDirection(gridX, gridY, validDirections) {
            // Calculer un score pour chaque direction basé sur les bombes et explosions
            const directionScores = validDirections.map(dir => {
                const newGridX = gridX + dir.dx;
                const newGridY = gridY + dir.dy;
                
                // Score initial: plus c'est loin des bombes, mieux c'est
                let score = 10;
                
                // Réduire le score si proche d'une bombe ou dans sa ligne/colonne
                gameState.bombs.forEach(bomb => {
                    const distX = Math.abs(bomb.x - newGridX);
                    const distY = Math.abs(bomb.y - newGridY);
                    
                    // Si dans la ligne ou colonne d'une bombe
                    if ((distX === 0 && distY <= bomb.range) || 
                        (distY === 0 && distX <= bomb.range)) {
                        score -= 5;
                    }
                    
                    // Si très proche d'une bombe
                    if (distX + distY <= 2) {
                        score -= 3;
                    }
                });
                
                // Réduire encore plus si dans une explosion active
                const inExplosion = gameState.explosions.some(explosion => {
                    return explosion.cells.some(cell => cell.x === newGridX && cell.y === newGridY);
                });
                
                if (inExplosion) {
                    score -= 10;
                }
                
                return { direction: dir, score: score };
            });
            
            // Trier par score (meilleur score en premier)
            directionScores.sort((a, b) => b.score - a.score);
            
            // Retourner la meilleure direction
            return directionScores[0].direction;
        }

        // Trouver le bonus le plus proche
        function findNearestBonus(gridX, gridY) {
            let nearestBonus = null;
            let minDistance = Infinity;
            
            for (const bonus of gameState.bonuses) {
                const distance = Math.abs(bonus.x - gridX) + Math.abs(bonus.y - gridY);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestBonus = bonus;
                }
            }
            
            if (nearestBonus) {
                return {
                    bonus: nearestBonus,
                    distance: minDistance
                };
            }
            
            return null;
        }

        // L'IA place une bombe
        function tryPlaceAIBomb(aiPlayer) {
            // Obtenir la position de la grille
            const gridX = Math.floor(aiPlayer.x / TILE_SIZE);
            const gridY = Math.floor(aiPlayer.y / TILE_SIZE);
            
            // Vérifier si une bombe est déjà présente à cet endroit
            const bombsAtPosition = gameState.bombs.filter(bomb => 
                bomb.x === gridX && bomb.y === gridY
            );
            
            // Compte le nombre de bombes actives de l'IA
            const activeBombs = gameState.bombs.filter(bomb => 
                bomb.playerId === aiPlayerId
            );
            
            // Placer la bombe si possible
            if (bombsAtPosition.length === 0 && activeBombs.length < aiPlayer.maxBombs) {
                const newBomb = {
                    id: generateId(),
                    playerId: aiPlayerId,
                    x: gridX,
                    y: gridY,
                    range: aiPlayer.bombRange,
                    timer: Date.now() + BOMB_TIMER
                };
                
                // Vérifier si placer une bombe est sécuritaire
                // (l'IA a au moins une direction pour s'échapper)
                const directions = [
                    { dx: 0, dy: -1 }, // haut
                    { dx: 0, dy: 1 },  // bas
                    { dx: -1, dy: 0 }, // gauche
                    { dx: 1, dy: 0 }   // droite
                ];
                
                let hasEscape = false;
                for (const dir of directions) {
                    const newX = (gridX + dir.dx);
                    const newY = (gridY + dir.dy);
                    
                    if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE &&
                        gameState.map[newY][newX] === TILE_TYPES.EMPTY) {
                        hasEscape = true;
                        break;
                    }
                }
                
                // Vérifier s'il est stratégique de poser une bombe ici
                const isStrategic = isStrategicToBomb(gridX, gridY);
                
                // Seulement placer la bombe si l'IA peut s'échapper et que c'est stratégique
                if (hasEscape && isStrategic) {
                    // Ajouter la bombe à Firebase
                    database.ref(`games/${gameState.roomId}/bombs`).push(newBomb);
                    updateDebugInfo("Bombe posée");
                    return true;
                }
            }
            
            return false;
        }

        // Vérifier s'il est stratégique de poser une bombe
        function isStrategicToBomb(gridX, gridY) {
            // Si près du joueur, c'est stratégique
            const player = gameState.players['player1'];
            if (player && player.alive) {
                const playerGridX = Math.floor(player.x / TILE_SIZE);
                const playerGridY = Math.floor(player.y / TILE_SIZE);
                
                const distX = Math.abs(playerGridX - gridX);
                const distY = Math.abs(playerGridY - gridY);
                
                // Si le joueur est dans la portée potentielle de la bombe
                if ((distX === 0 && distY <= 2) || (distY === 0 && distX <= 2)) {
                    return true;
                }
            }
            
            // Si des briques peuvent être détruites, c'est aussi stratégique
            const directions = [
                { dx: 0, dy: -1 }, // haut
                { dx: 0, dy: 1 },  // bas
                { dx: -1, dy: 0 }, // gauche
                { dx: 1, dy: 0 }   // droite
            ];
            
            return directions.some(dir => {
                const x = gridX + dir.dx;
                const y = gridY + dir.dy;
                
                return (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE && 
                       gameState.map[y][x] === TILE_TYPES.BRICK);
            });
        }

        // Mettre à jour les infos de debug
        function updateDebugInfo(action = "") {
            if (!debugDiv) return;
            
            // Mettre à jour l'action de l'IA
            const aiActionSpan = document.getElementById('aiAction');
            if (aiActionSpan) {
                aiActionSpan.textContent = action;
            }
            
            // Mettre à jour les positions et stats
            if (gameState.players) {
                // IA
                const ai = gameState.players[aiPlayerId];
                if (ai) {
                    const aiGridX = Math.floor(ai.x / TILE_SIZE);
                    const aiGridY = Math.floor(ai.y / TILE_SIZE);
                    
                    const aiGridXSpan = document.getElementById('aiGridX');
                    const aiGridYSpan = document.getElementById('aiGridY');
                    const aiBombsSpan = document.getElementById('aiBombs');
                    const aiPowerSpan = document.getElementById('aiPower');
                    
                    if (aiGridXSpan) aiGridXSpan.textContent = aiGridX;
                    if (aiGridYSpan) aiGridYSpan.textContent = aiGridY;
                    if (aiBombsSpan) aiBombsSpan.textContent = ai.maxBombs;
                    if (aiPowerSpan) aiPowerSpan.textContent = ai.bombRange;
                }
                
                // Joueur
                const player = gameState.players['player1'];
                if (player) {
                    const playerGridX = Math.floor(player.x / TILE_SIZE);
                    const playerGridY = Math.floor(player.y / TILE_SIZE);
                    
                    const playerGridXSpan = document.getElementById('playerGridX');
                    const playerGridYSpan = document.getElementById('playerGridY');
                    const playerBombsSpan = document.getElementById('playerBombs');
                    const playerPowerSpan = document.getElementById('playerPower');
                    
                    if (playerGridXSpan) playerGridXSpan.textContent = playerGridX;
                    if (playerGridYSpan) playerGridYSpan.textContent = playerGridY;
                    if (playerBombsSpan) playerBombsSpan.textContent = player.maxBombs;
                    if (playerPowerSpan) playerPowerSpan.textContent = player.bombRange;
                }
            }
        }

        //--------------------------------------------------
        // GESTION DES BOMBES ET EXPLOSIONS
        //--------------------------------------------------

        // Placer une bombe
        function placeBomb() {
            if (!gameState.roomId || !gameState.playerId || !gameState.gameStarted) return;
            
            const player = gameState.players[gameState.playerId];
            if (!player || !player.alive) return;
            
            // Obtenir la position de la grille
            const gridX = Math.floor(player.x / TILE_SIZE);
            const gridY = Math.floor(player.y / TILE_SIZE);
            
            // Vérifier si une bombe est déjà présente à cet endroit
            const bombsAtPosition = gameState.bombs.filter(bomb => 
                bomb.x === gridX && bomb.y === gridY
            );
            
            // Compte le nombre de bombes actives de ce joueur
            const activeBombs = gameState.bombs.filter(bomb => 
                bomb.playerId === gameState.playerId
            );
            
            // Placer la bombe si possible
            if (bombsAtPosition.length === 0 && activeBombs.length < player.maxBombs) {
                const newBomb = {
                    id: generateId(),
                    playerId: gameState.playerId,
                    x: gridX,
                    y: gridY,
                    range: player.bombRange,
                    timer: Date.now() + BOMB_TIMER // Timestamp pour l'explosion
                };
                
                // Ajouter la bombe au jeu
                database.ref(`games/${gameState.roomId}/bombs`).push(newBomb);
            }
        }

        // Déclencher l'explosion d'une bombe
        function explodeBomb(bomb) {
            if (!gameState.map || !bomb) return;
            
            const explosionCells = [];
            const { x, y, range } = bomb;
            
            // Ajouter la cellule centrale
            explosionCells.push({ x, y });
            
            // Explorer les 4 directions (haut, droite, bas, gauche)
            const directions = [
                { dx: 0, dy: -1 }, // haut
                { dx: 1, dy: 0 },  // droite
                { dx: 0, dy: 1 },  // bas
                { dx: -1, dy: 0 }  // gauche
            ];
            
            // Pour chaque direction, étendre jusqu'à rencontrer un obstacle ou atteindre la portée
            directions.forEach(dir => {
                for (let i = 1; i <= range; i++) {
                    const newX = x + dir.dx * i;
                    const newY = y + dir.dy * i;
                    
                    // Vérifier si on est toujours dans les limites de la carte
                    if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
                        break;
                    }
                    
                    // Si on rencontre un mur, arrêter dans cette direction
                    if (gameState.map[newY][newX] === TILE_TYPES.WALL) {
                        break;
                    }
                    
                    // Ajouter cette cellule à l'explosion
                    explosionCells.push({ x: newX, y: newY });
                    
                    // Si on rencontre une brique, la détruire et arrêter dans cette direction
                    if (gameState.map[newY][newX] === TILE_TYPES.BRICK) {
                        // Mettre à jour la carte dans Firebase
                        database.ref(`games/${gameState.roomId}/map/${newY}/${newX}`).set(TILE_TYPES.EMPTY);
                        
                        // Possibilité de créer un bonus
                        if (Math.random() < BONUS_PROBABILITY) {
                            spawnBonus(newX, newY);
                        }
                        
                        break;
                    }
                }
            });
            
            // Créer l'explosion dans Firebase
            const explosion = {
                cells: explosionCells,
                timestamp: Date.now(),
                duration: EXPLOSION_DURATION
            };
            
            // Ajouter l'explosion à Firebase
            database.ref(`games/${gameState.roomId}/explosions`).push(explosion);
            
            // Supprimer la bombe de Firebase
            if (bomb.id) {
                database.ref(`games/${gameState.roomId}/bombs/${bomb.id}`).remove();
            } else {
                // Si pas d'ID (parce que ça vient d'être ajouté et pas encore synchronisé)
                const bombRef = database.ref(`games/${gameState.roomId}/bombs`);
                bombRef.once('value', snapshot => {
                    snapshot.forEach(childSnapshot => {
                        const b = childSnapshot.val();
                        if (b.x === bomb.x && b.y === bomb.y && b.playerId === bomb.playerId) {
                            childSnapshot.ref.remove();
                        }
                    });
                });
            }
            
            // Vérifier si des joueurs sont touchés par l'explosion
            checkPlayersInExplosion(explosionCells);
            
            // Vérifier si des bonus sont touchés par l'explosion
            checkBonusesInExplosion(explosionCells);
            
            // Vérifier si d'autres bombes sont touchées par l'explosion (réaction en chaîne)
            checkBombsInExplosion(explosionCells, bomb.id);
        }

        // Vérifier si des joueurs sont touchés par l'explosion
        function checkPlayersInExplosion(explosionCells) {
            for (const playerId in gameState.players) {
                const player = gameState.players[playerId];
                if (!player || !player.alive) continue;
                
                // Obtenir la position du joueur sur la grille
                const playerGridX = Math.floor(player.x / TILE_SIZE);
                const playerGridY = Math.floor(player.y / TILE_SIZE);
                
                // Vérifier si le joueur est dans une cellule touchée par l'explosion
                const isHit = explosionCells.some(cell => cell.x === playerGridX && cell.y === playerGridY);
                
                if (isHit) {
                    // Marquer le joueur comme mort
                    database.ref(`games/${gameState.roomId}/players/${playerId}/alive`).set(false);
                }
            }
        }

        // Vérifier si des bonus sont touchés par l'explosion
        function checkBonusesInExplosion(explosionCells) {
            const bonusesToRemove = [];
            
            // Parcourir tous les bonus
            for (const bonus of gameState.bonuses) {
                // Vérifier si ce bonus est touché par l'explosion
                if (explosionCells.some(cell => cell.x === bonus.x && cell.y === bonus.y)) {
                    bonusesToRemove.push(bonus.id);
                }
            }
            
            // Supprimer les bonus touchés
            for (const bonusId of bonusesToRemove) {
                database.ref(`games/${gameState.roomId}/bonuses/${bonusId}`).remove();
            }
        }

        // Vérifier si d'autres bombes sont touchées par l'explosion
        function checkBombsInExplosion(explosionCells, excludeBombId) {
            for (const bomb of gameState.bombs) {
                if (bomb.id === excludeBombId) continue;
                
                // Vérifier si la bombe est dans une cellule touchée par l'explosion
                const isHit = explosionCells.some(cell => cell.x === bomb.x && cell.y === bomb.y);
                
                if (isHit) {
                    // Exploser cette bombe immédiatement (réaction en chaîne)
                    explodeBomb(bomb);
                }
            }
        }

        // Mettre à jour les explosions
        function updateExplosions() {
            const currentTime = Date.now();
            
            // Vérifier si des bombes doivent exploser
            for (const bomb of gameState.bombs) {
                if (bomb.timer && bomb.timer <= currentTime) {
                    explodeBomb(bomb);
                }
            }
            
            // Supprimer les explosions terminées
            for (const explosion of gameState.explosions) {
                if (explosion.timestamp + explosion.duration <= currentTime) {
                    if (explosion.id) {
                        database.ref(`games/${gameState.roomId}/explosions/${explosion.id}`).remove();
                    }
                }
            }
        }

        // Dessiner les bombes
        function renderBombs() {
            if (!gameState.bombs) return;
            
            for (const bomb of gameState.bombs) {
                // Calculer l'animation de la bombe (pulsation)
                const timeLeft = bomb.timer - Date.now();
                const scale = 1 + 0.2 * Math.sin(timeLeft / 200);
                
                // Dessiner une noix de coco comme bombe
                ctx.fillStyle = '#654321'; // Marron pour la noix de coco
                ctx.beginPath();
                ctx.arc(
                    bomb.x * TILE_SIZE + TILE_SIZE/2, 
                    bomb.y * TILE_SIZE + TILE_SIZE/2, 
                    TILE_SIZE/3 * scale, 
                    0, 
                    Math.PI * 2
                );
                ctx.fill();
                
                // Ajouter des détails à la noix de coco
                ctx.fillStyle = '#543210';
                ctx.beginPath();
                ctx.arc(
                    bomb.x * TILE_SIZE + TILE_SIZE/2 - 3, 
                    bomb.y * TILE_SIZE + TILE_SIZE/2 - 3, 
                    2, 
                    0, 
                    Math.PI * 2
                );
                ctx.arc(
                    bomb.x * TILE_SIZE + TILE_SIZE/2 + 3, 
                    bomb.y * TILE_SIZE + TILE_SIZE/2 - 3, 
                    2, 
                    0, 
                    Math.PI * 2
                );
                ctx.arc(
                    bomb.x * TILE_SIZE + TILE_SIZE/2, 
                    bomb.y * TILE_SIZE + TILE_SIZE/2 + 3, 
                    2, 
                    0, 
                    Math.PI * 2
                );
                ctx.fill();
                
                // Ajouter une petite feuille comme mèche
                ctx.fillStyle = '#00AA00';
                ctx.beginPath();
                ctx.moveTo(
                    bomb.x * TILE_SIZE + TILE_SIZE/2, 
                    bomb.y * TILE_SIZE + TILE_SIZE/2 - TILE_SIZE/3
                );
                ctx.lineTo(
                    bomb.x * TILE_SIZE + TILE_SIZE/2 + 5, 
                    bomb.y * TILE_SIZE + TILE_SIZE/2 - TILE_SIZE/2
                );
                ctx.lineTo(
                    bomb.x * TILE_SIZE + TILE_SIZE/2 - 5, 
                    bomb.y * TILE_SIZE + TILE_SIZE/2 - TILE_SIZE/2 - 2
                );
                ctx.fill();
            }
        }

        // Dessiner les explosions
        function renderExplosions() {
            if (!gameState.explosions) return;
            
            const currentTime = Date.now();
            
            for (const explosion of gameState.explosions) {
                // Calculer l'opacité en fonction du temps écoulé
                const timeElapsed = currentTime - explosion.timestamp;
                const opacity = 1 - (timeElapsed / explosion.duration);
                
                if (opacity <= 0) continue;
                
                // Dessiner chaque cellule de l'explosion
                for (const cell of explosion.cells) {
                    // Utiliser un dégradé pour l'effet d'explosion tropicale
                    try {
                        const gradient = ctx.createRadialGradient(
                            cell.x * TILE_SIZE + TILE_SIZE/2,
                            cell.y * TILE_SIZE + TILE_SIZE/2,
                            0,
                            cell.x * TILE_SIZE + TILE_SIZE/2,
                            cell.y * TILE_SIZE + TILE_SIZE/2,
                            TILE_SIZE/2
                        );
                        
                        // Couleurs chaudes pour une explosion tropicale - jaune, orange, rouge
                        gradient.addColorStop(0, `rgba(255, 255, 0, ${opacity})`);
                        gradient.addColorStop(0.6, `rgba(255, 165, 0, ${opacity * 0.9})`);
                        gradient.addColorStop(1, `rgba(255, 69, 0, ${opacity * 0.7})`);
                        
                        ctx.fillStyle = gradient;
                        ctx.fillRect(
                            cell.x * TILE_SIZE, 
                            cell.y * TILE_SIZE, 
                            TILE_SIZE, 
                            TILE_SIZE
                        );
                        
                        // Ajouter des particules façon "confettis" pour effet reggae
                        if (Math.random() < 0.4) {
                            const particleColors = ['#00FF00', '#FFFF00', '#FF0000']; // Vert, jaune, rouge (couleurs reggae)
                            const color = particleColors[Math.floor(Math.random() * particleColors.length)];
                            
                            ctx.fillStyle = color;
                            ctx.fillRect(
                                cell.x * TILE_SIZE + Math.random() * TILE_SIZE, 
                                cell.y * TILE_SIZE + Math.random() * TILE_SIZE, 
                                3, 
                                3
                            );
                        }
                    } catch (e) {
                        console.error("Erreur lors du rendu d'explosion:", e);
                    }
                }
            }
        }

        //--------------------------------------------------
        // SYSTÈME DE BONUS
        //--------------------------------------------------

        // Faire apparaître un bonus
        function spawnBonus(x, y) {
            // Choisir un type de bonus aléatoire
            const bonusType = Math.floor(Math.random() * 3); // 0 = bombe+, 1 = puissance+, 2 = vitesse+
            
            const bonusId = generateId();
            
            // Créer le bonus
            const bonus = {
                id: bonusId,
                type: bonusType,
                x: x,
                y: y,
                expireTime: Date.now() + BONUS_DURATION
            };
            
            // Ajouter le bonus à Firebase
            database.ref(`games/${gameState.roomId}/bonuses/${bonusId}`).set(bonus);
        }

        // Obtenir un bonus à une position
        function getBonusAt(x, y) {
            return gameState.bonuses.find(bonus => bonus.x === x && bonus.y === y);
        }

        // Collecter un bonus
        function collectBonus(playerId, bonus) {
            if (!bonus) return;
            
            const player = gameState.players[playerId];
            if (!player) return;
            
            // Appliquer l'effet du bonus
            switch (bonus.type) {
                case BONUS_TYPES.BOMB:
                    player.maxBombs++;
                    break;
                case BONUS_TYPES.POWER:
                    player.bombRange++;
                    break;
                case BONUS_TYPES.SPEED:
                    player.speedMultiplier = (player.speedMultiplier || 1) + 0.2;
                    break;
            }
            
            // Mettre à jour le joueur dans Firebase
            database.ref(`games/${gameState.roomId}/players/${playerId}`).update({
                maxBombs: player.maxBombs,
                bombRange: player.bombRange,
                speedMultiplier: player.speedMultiplier
            });
            
            // Supprimer le bonus
            database.ref(`games/${gameState.roomId}/bonuses/${bonus.id}`).remove();
        }

        // Vérifier les bonus collectés
        function checkBonusCollection() {
            // Pour chaque joueur
            for (const playerId in gameState.players) {
                const player = gameState.players[playerId];
                if (!player || !player.alive) continue;
                
                // Obtenir la position du joueur sur la grille
                const playerGridX = Math.floor(player.x / TILE_SIZE);
                const playerGridY = Math.floor(player.y / TILE_SIZE);
                
                // Vérifier s'il y a un bonus à cette position
                const bonus = getBonusAt(playerGridX, playerGridY);
                if (bonus) {
                    collectBonus(playerId, bonus);
                }
            }
        }

        // Mettre à jour les bonus (expiration)
        function updateBonuses() {
            const currentTime = Date.now();
            
            // Supprimer les bonus expirés
            for (const bonus of gameState.bonuses) {
                if (bonus.expireTime && bonus.expireTime <= currentTime) {
                    database.ref(`games/${gameState.roomId}/bonuses/${bonus.id}`).remove();
                }
            }
        }

        // Dessiner les bonus
        function renderBonuses() {
            if (!gameState.bonuses || gameState.bonuses.length === 0) return;
            
            for (const bonus of gameState.bonuses) {
                // Position du bonus
                const x = bonus.x * TILE_SIZE + TILE_SIZE/2;
                const y = bonus.y * TILE_SIZE + TILE_SIZE/2;
                
                // Animation de pulsation
                const scale = 1 + 0.1 * Math.sin(Date.now() / 300);
                const size = TILE_SIZE * 0.6 * scale;
                
                // Couleur selon le type
                let color;
                let symbol;
                
                switch (bonus.type) {
                    case BONUS_TYPES.BOMB:
                        color = '#f5a623'; // Orange
                        symbol = 'B';
                        break;
                    case BONUS_TYPES.POWER:
                        color = '#ff5252'; // Rouge
                        symbol = 'P';
                        break;
                    case BONUS_TYPES.SPEED:
                        color = '#7ed321'; // Vert
                        symbol = 'S';
                        break;
                }
                
                // Dessiner le cercle du bonus
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, size/2, 0, Math.PI * 2);
                ctx.fill();
                
                // Bordure
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, size/2, 0, Math.PI * 2);
                ctx.stroke();
                ctx.lineWidth = 1;
                
                // Symbole
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Comic Sans MS';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(symbol, x, y);
            }
        }

        //--------------------------------------------------
        // GESTION DU MULTIJOUEUR
        //--------------------------------------------------

        // Créer une nouvelle partie multijoueur
        function createGame() {
            log("Création d'une nouvelle partie multijoueur");
            // Générer un code de salle si non spécifié
            const roomId = roomInput.value || generateId();
            roomInput.value = roomId;
            gameState.roomId = roomId;
            gameState.playerId = 'player1';
            aiMode = false;
            
            // Créer la partie dans Firebase
            const gameRef = database.ref(`games/${roomId}`);
            gameRef.set({
                map: generateMap(),
                players: {
                    player1: createPlayer(0, 0, '#ff6b6b')
                },
                bombs: {},
                explosions: {},
                bonuses: {},
                gameStarted: false
            });
            
            // Rejoindre la partie
            joinGame(roomId, 'player1');
            gameInfo.textContent = `Partie créée ! Code: ${roomId} - En attente d'un autre joueur...`;
        }

        // Rejoindre une partie existante
        function joinExistingGame() {
            log("Tentative de rejoindre une partie existante");
            const roomId = roomInput.value;
            if (!roomId) {
                alert('Veuillez entrer un code de partie');
                return;
            }
            
            // Vérifier si la partie existe
            const gameRef = database.ref(`games/${roomId}`);
            gameRef.once('value', (snapshot) => {
                const gameData = snapshot.val();
                if (!gameData) {
                    alert('Partie non trouvée');
                    return;
                }
                
                // Vérifier si la partie est complète
                if (gameData.players && gameData.players.player2) {
                    alert('Partie déjà complète');
                    return;
                }
                
                // Rejoindre en tant que joueur 2
                gameState.roomId = roomId;
                gameState.playerId = 'player2';
                aiMode = false;
                
                // Ajouter le joueur 2 à la partie
                gameRef.child('players/player2').set(createPlayer(GRID_SIZE - 1, GRID_SIZE - 1, '#4ecdc4'));
                gameRef.child('gameStarted').set(true);
                
                // Rejoindre la partie
                joinGame(roomId, 'player2');
            });
        }

        // Créer une partie solo contre l'IA
        function createSinglePlayerGame() {
            log("Création d'une partie solo contre l'IA");
            // Générer un code de salle pour le mode solo
            const roomId = 'solo_' + generateId();
            roomInput.value = roomId;
            gameState.roomId = roomId;
            gameState.playerId = 'player1';
            aiMode = true;
            
            // Créer la partie dans Firebase avec le joueur humain et l'IA
            const gameRef = database.ref(`games/${roomId}`);
            gameRef.set({
                map: generateMap(),
                players: {
                    player1: createPlayer(0, 0, '#ff6b6b'),
                    [aiPlayerId]: createPlayer(GRID_SIZE - 1, GRID_SIZE - 1, '#4ecdc4')
                },
                bombs: {},
                explosions: {},
                bonuses: {},
                gameStarted: true
            });
            
            // Rejoindre la partie
            joinGame(roomId, 'player1');
            gameInfo.textContent = `Survivez sur l'île contre le pirate IA - Vous êtes le Rasta Rouge`;
            
            // Démarrer l'IA
            startAI();
        }

        // Rejoindre une partie et configurer les écouteurs
        function joinGame(roomId, playerId) {
            log(`Rejoindre la partie ${roomId} en tant que ${playerId}`);
            const gameRef = database.ref(`games/${roomId}`);
            
            // Écouter les changements d'état du jeu
            gameRef.on('value', (snapshot) => {
                const gameData = snapshot.val();
                if (!gameData) return;
                
                // Mettre à jour l'état du jeu local
                gameState.map = gameData.map;
                gameState.players = gameData.players || {};
                
                // Convertir les objets en tableaux
                gameState.bombs = gameData.bombs ? Object.values(gameData.bombs) : [];
                gameState.explosions = gameData.explosions ? Object.values(gameData.explosions) : [];
                gameState.bonuses = gameData.bonuses ? Object.values(gameData.bonuses) : [];
                
                gameState.gameStarted = gameData.gameStarted;
                
                // Afficher un message quand le jeu commence
                if (gameState.gameStarted) {
                    if (aiMode) {
                        gameInfo.textContent = `Survivez sur l'île contre le pirate IA - Vous êtes le Rasta Rouge`;
                    } else if (gameData.players.player1 && gameData.players.player2) {
                        gameInfo.textContent = `Combat sur l'île - Vous êtes le ${playerId === 'player1' ? 'Rasta Rouge' : 'Surfeur Bleu'}`;
                    }
                }
            });
            
            // Configurer les déconnexions
            gameRef.child(`players/${playerId}`).onDisconnect().remove();
            database.ref(`.info/connected`).on('value', (snapshot) => {
                if (snapshot.val() === false) return;
                
                // Nettoyer la partie si tous les joueurs sont déconnectés
                gameRef.onDisconnect().remove();
            });
            
            // Cacher les contrôles de salle et cacher les contrôles de jeu jusqu'à la fin
            document.getElementById('roomControls').style.display = 'none';
            document.getElementById('gameControls').style.display = 'none';
        }

        // Fonction pour redémarrer la partie
        function restartGame() {
            log("Redémarrage de la partie");
            // Si on est en mode solo avec IA
            if (aiMode) {
                // Nettoyer l'intervalle de l'IA pour éviter les doublons
                if (aiMoveInterval) {
                    clearInterval(aiMoveInterval);
                }
                
                // Régénérer une carte et réinitialiser les joueurs
                const roomId = 'solo_' + generateId();
                gameState.roomId = roomId;
                
                // Créer une nouvelle partie
                const gameRef = database.ref(`games/${roomId}`);
                gameRef.set({
                    map: generateMap(),
                    players: {
                        player1: createPlayer(0, 0, '#ff6b6b'),
                        [aiPlayerId]: createPlayer(GRID_SIZE - 1, GRID_SIZE - 1, '#4ecdc4')
                    },
                    bombs: {},
                    explosions: {},
                    bonuses: {},
                    gameStarted: true
                });
                
                // Rejoindre la partie
                joinGame(roomId, 'player1');
                gameInfo.textContent = `Survivez sur l'île contre le pirate IA - Vous êtes le Rasta Rouge`;
                
                // Démarrer l'IA
                startAI();
                
                // Cacher les contrôles de jeu jusqu'à la fin de partie
                document.getElementById('gameControls').style.display = 'none';
            } else {
                // Pour les parties multijoueur, revenir à l'écran de création de partie
                document.getElementById('roomControls').style.display = 'block';
                document.getElementById('gameControls').style.display = 'none';
                
                // Déconnecter la partie actuelle
                if (gameState.roomId) {
                    database.ref(`games/${gameState.roomId}`).off();
                }
                
                // Réinitialiser l'état
                gameState.roomId = null;
                gameState.playerId = null;
                gameState.map = [];
                gameState.players = {};
                gameState.bombs = [];
                gameState.explosions = [];
                gameState.bonuses = [];
                gameState.gameStarted = false;
            }
        }

        // Fonction pour revenir au menu principal
        function returnToHome() {
            log("Retour à l'accueil");
            // Rediriger vers la page d'accueil
            window.location.href = 'index.html';
        }

        //--------------------------------------------------
        // ÉCOUTEURS D'ÉVÉNEMENTS
        //--------------------------------------------------

        // Gérer les entrées clavier
        window.addEventListener('keydown', (e) => {
            gameState.keys[e.key] = true;
            
            // Touche espace pour poser une bombe
            if (e.key === ' ' && gameState.gameStarted) {
                placeBomb();
            }
            
            // Éviter le scroll de la page avec les flèches
            if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(e.key)) {
                e.preventDefault();
            }
        });

        window.addEventListener('keyup', (e) => {
            gameState.keys[e.key] = false;
        });

        // Nettoyage lors de la fermeture de la page
        window.addEventListener('beforeunload', () => {
            if (aiMoveInterval) {
                clearInterval(aiMoveInterval);
            }
        });

        // Ajout des écouteurs d'événements pour les boutons avec système de log
        log("Ajout des écouteurs d'événements pour les boutons");
        
        const createBtn = document.getElementById('createBtn');
        if (createBtn) {
            createBtn.addEventListener('click', function() {
                log("Bouton createBtn cliqué");
                createGame();
            });
            log("Écouteur ajouté pour createBtn");
        } else {
            console.error("Élément createBtn non trouvé");
        }
        
        const joinBtn = document.getElementById('joinBtn');
        if (joinBtn) {
            joinBtn.addEventListener('click', function() {
                log("Bouton joinBtn cliqué");
                joinExistingGame();
            });
            log("Écouteur ajouté pour joinBtn");
        } else {
            console.error("Élément joinBtn non trouvé");
        }
        
        const singlePlayerBtn = document.getElementById('singlePlayerBtn');
        if (singlePlayerBtn) {
            singlePlayerBtn.addEventListener('click', function() {
                log("Bouton singlePlayerBtn cliqué");
                createSinglePlayerGame();
            });
            log("Écouteur ajouté pour singlePlayerBtn");
        } else {
            console.error("Élément singlePlayerBtn non trouvé");
        }
        
        const restartBtn = document.getElementById('restartBtn');
        if (restartBtn) {
            restartBtn.addEventListener('click', function() {
                log("Bouton restartBtn cliqué");
                restartGame();
            });
            log("Écouteur ajouté pour restartBtn");
        } else {
            console.error("Élément restartBtn non trouvé");
        }
        
        const homeBtn = document.getElementById('homeBtn');
        if (homeBtn) {
            homeBtn.addEventListener('click', function() {
                log("Bouton homeBtn cliqué");
                returnToHome();
            });
            log("Écouteur ajouté pour homeBtn");
        } else {
            console.error("Élément homeBtn non trouvé");
        }

        // Boucle de jeu principale
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // Démarrer le jeu
        log("Démarrage de la boucle de jeu");
        gameLoop();
    </script>
</body>
</html>